
Java allows a class to implement **multiple interfaces** because interfaces are **pure contracts** — they only define **method signatures** (behavior), not state (fields).

### **How it avoids the diamond problem**

- **Diamond problem:** happens in multiple class inheritance when a class inherits **the same method from multiple parents**, creating ambiguity.
    
- **Interfaces avoid this** because:
    
    1. They **cannot have instance fields**, so there is no conflicting state.
        
    2. Their **methods are abstract (or default)**, so the implementing class **decides the actual behavior**, removing ambiguity.

```
interface A { void show(); }
interface B { void show(); }

class C implements A, B {
    public void show() { System.out.println("Implemented in C"); }
}
```



### **What happens when both interfaces has default implementation?**
```
interface A {
    default void show() { System.out.println("A's show"); }
}

interface B {
    default void show() { System.out.println("B's show"); }
}

class C implements A, B {
    public void show() { System.out.println("Implemented in C"); }
}
```

- Both interfaces `A` and `B` define **default methods** with the same signature.
- If `C` does **not override `show()`**, the compiler will **throw an error**, because Java **does not know which default method to inherit**.
    This is Java’s way of handling the diamond problem for default methods.


### **What happens if only interface a has a default?**
```
interface A {
    default void show() { System.out.println("A's show"); }
}

interface B {
    void show(); // abstract method (no default)
}

class C implements A, B {
    // No override here
}
```

- Class C **inherits the default implementation from A**.
- No compiler error occurs because there is **no conflict** — only one default exists.
    So C can just use **A’s default `show()`** without overriding.
- Optional Overriding: C **can still override** `show()` if it wants its own behavior