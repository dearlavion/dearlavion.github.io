### **What**

> **Polymorphism** allows objects to take multiple forms; allows objects respond differently to the same method call (depending on their actual type on runtime)

### **Why**

> To write **flexible, reusable, and scalable** code.

### **How

- **Compile-time (Method Overloading)**
    
    - Same method name with different parameters within the same class.
        
- **Runtime (Method Overriding)**
    
    - Same method name and parameters in **subclasses or implementing classes**.
        
    - Applies to:
        
        1. **Parent → Child class**: Subclass overrides a method from the parent.
            
        2. **Abstract class → Concrete class**: Concrete class provides implementation for abstract methods.
            
        3. **Interface → Implementing class**: Class implements interface methods.

```
// Overloading example
class MathUtil {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}

// Overriding example
class Animal { void sound() { System.out.println("Some sound"); } }
class Dog extends Animal { void sound() { System.out.println("Bark"); } }

Animal a = new Dog();
a.sound(); // Outputs "Bark" – runtime polymorphism
```