
### ✅ Interview-Friendly Script

Terminal operations **trigger the stream pipeline**, producing results from all lazy intermediate operations.
> 
> - `collect(Collectors.toList())`, `toSet()`, `toMap()` gather elements into collections.
> - `groupingBy()` and `partitioningBy()` organize data by key or predicate.
> - `joining()` combines strings, `counting()` counts elements, and `summarizingInt()` computes 
> - `reduce()` is a general-purpose aggregation. 

| Category              | Terminal Operation    | Returns                   | Purpose                                       |
| --------------------- | --------------------- | ------------------------- | --------------------------------------------- |
| **Collecting**        | `collect()`           | Collection / Map / Object | Gather stream elements into a result          |
| **Iteration**         | `forEach()`           | `void`                    | Perform an action on each element             |
| **Counting**          | `count()`             | `long`                    | Count number of elements                      |
| **Reduction**         | `reduce()`            | Optional / value          | Combine elements into a single result         |
| **Finding**           | `findFirst()`         | `Optional<T>`             | Find first element                            |
|                       | `findAny()`           | `Optional<T>`             | Find any element (useful in parallel streams) |
| **Matching**          | `anyMatch()`          | `boolean`                 | Check if any element matches condition        |
|                       | `allMatch()`          | `boolean`                 | Check if all elements match condition         |
|                       | `noneMatch()`         | `boolean`                 | Check if no elements match condition          |
| **Min / Max**         | `min(Comparator)`     | `Optional<T>`             | Find minimum element                          |
|                       | `max(Comparator)`     | `Optional<T>`             | Find maximum element                          |
| **Primitive Streams** | `sum()`               | `int / long / double`     | Sum of elements                               |
|                       | `average()`           | `OptionalDouble`          | Average value                                 |
|                       | `summaryStatistics()` | Statistics object         | Min, max, avg, count, sum                     |

## **Terminal Operations: Collect & Collectors**
**`collect()`** is used to **gather results** from a stream.  
Java provides **Collectors** to define **how to collect** data.

a) **Collect to List or Set**
```
List<String> namesList = users.stream()
                              .map(User::getName)
                              .collect(Collectors.toList());

Set<String> namesSet = users.stream()
                            .map(User::getName)
                            .collect(Collectors.toSet());
```
**Tip:** `List` preserves order, `Set` removes duplicates.

b) **Collect to Map**
```
Map<String, Integer> userAgeMap = users.stream()
                                      .collect(Collectors.toMap(
                                          User::getName,   // key
                                          User::getAge     // value
                                      ));
```

c) **groupingBy()** — Group Elements
**Example:** Group users by department
```
Map<String, List<User>> byDept =  
	users.stream().collect(Collectors.groupingBy(User::getDepartment));
```
Result: `"HR" -> List of HR users, "IT" -> List of IT users`

d) **partitioningBy()** — Split by Predicate
**Example:** Users older than 25
```
Map<Boolean, List<User>> partitioned = users.stream()
        .collect(Collectors.partitioningBy(u -> u.getAge() > 25));
```
Result:
- `true` → users older than 25
- `false` → users 25 or younger

e) **joining()** — Combine Strings
```
String namesJoined = users.stream()
                          .map(User::getName)
                          .collect(Collectors.joining(", "));

System.out.println(namesJoined); // Alice, Bob, Charlie
```

f) **counting()** — Count Elements
```
long count = users.stream()
                  .filter(u -> u.getAge() > 25)
                  .collect(Collectors.counting());

System.out.println(count); // Number of users older than 25
```

g) **summarizingInt()** — Stats in One Go
```
IntSummaryStatistics stats = users.stream()
                                  .collect(Collectors.summarizingInt(User::getAge));

System.out.println(stats.getMax());   // Max age
System.out.println(stats.getMin());   // Min age
System.out.println(stats.getAverage()); // Average age
System.out.println(stats.getCount());   // Count
```

h) **reduce()** — General Aggregation

`reduce()` takes many values and reduces them into a single value.

```
int totalAge = users.stream()
                    .map(User::getAge)
                    .reduce(0, Integer::sum);
  
  
This version of `reduce` has two parts: 
reduce(identity, accumulator)
  
|Part          |        Meaning          |
|--------------|-------------------------|
|`0`           |Identity (starting value)|
|`Integer::sum`|How to combine two values| 
```


> `reduce` can **combine elements** into a single result using a binary function.

```
Optional<User> oldest = users.stream()
                    .reduce((u1, u2) -> u1.getAge() > u2.getAge() ? u1 : u2);
   
This version has no identity value:
reduce(BinaryOperator<T>)
```

For common cases, prefer built-ins:
```
int sum = users.stream().mapToInt(User::getAge).sum();

Optional<User> oldest = users.stream().max(Comparator.comparing(User::getAge));
```
These are:
- Clearer
- Less error-prone
- More readable in interviews