## Streams vs Collection
“Collections store data. Streams are **not data**, they are a pipeline to process data efficiently.”

| Feature         | Collection                       | Stream                                                           |
| --------------- | -------------------------------- | ---------------------------------------------------------------- |
| Represents      | Data storage                     | Computation pipeline                                             |
| Traversal       | Can iterate multiple times       | Traversal is consumed once                                       |
| Mutability      | Usually mutable (List, Set, Map) | Immutable pipeline operations                                    |
| Functional APIs | Needs manual loops               | Supports functional-style operations (`map`, `filter`, `reduce`) |
| Laziness        | No                               | Yes, intermediate operations are lazy                            |
```
List<String> names = List.of("Alice","Bob","Charlie");

// Collection usage
for(String name : names){
    System.out.println(name);
}

// Stream usage
names.stream().forEach(System.out::println);
```

## Intermediate vs Terminal Operations

- **Intermediate Operations:**
    - Return a **new Stream**
    - Can be **chained
    - **Lazy** — nothing happens until a terminal operation is called
    - Examples: `filter`, `map`, `sorted`, `distinct`, `peek
- **Terminal Operations:**
    - Trigger the **pipeline execution**
    - Return a **result** (not a Stream)
    - Examples: `collect`, `forEach`, `reduce`, `count`, `anyMatch`, `allMatch`

```
List<String> names = List.of("Alice","Bob","Charlie");

List<String> filtered = names.stream()      // Stream created
                             .filter(n -> n.startsWith("A")) // intermediate
                             .map(String::toUpperCase)      // intermediate
                             .collect(Collectors.toList()); // terminal

System.out.println(filtered); // [ALICE]

```

## Lazy Evaluation

- Streams **don’t process elements immediately**.
- Operations are only executed when a **terminal operation** is called.
- **Advantage:** Can optimize pipelines, avoid unnecessary computation.
```
List<String> names = List.of("Alice","Bob","Charlie");

names.stream()
     .filter(n -> {
         System.out.println("Filtering " + n);
         return n.startsWith("A");
     })
     .map(String::toUpperCase); // nothing printed yet!

// Terminal operation triggers evaluation
names.stream()
     .filter(n -> {
         System.out.println("Filtering " + n);
         return n.startsWith("A");
     })
     .map(String::toUpperCase)
     .forEach(System.out::println);

Output:
Filtering Alice
ALICE
Filtering Bob
Filtering Charlie

```

## Parallel Streams

- Allows **automatic parallel execution** using multiple threads
- Easy way to speed up processing on large collections
- **Caution:** Avoid shared mutable state (must be side-effect-free)

```
List<Integer> numbers = List.of(1,2,3,4,5,6,7,8,9,10);

int sum = numbers.parallelStream()
                 .mapToInt(Integer::intValue)
                 .sum();

System.out.println(sum); // 55

```
**Interview Tip:**
> “Parallel streams split the data internally and process chunks concurrently. Must be careful not to use mutable shared state inside the pipeline.”