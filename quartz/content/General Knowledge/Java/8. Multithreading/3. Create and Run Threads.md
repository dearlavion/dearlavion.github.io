
There are **4 main ways** to create threads in Java:
1. **Thread** ‚Äî low-level, simple, no reuse, not scalable
2. **Runnable** ‚Äî separates task from thread, preferred for one-off tasks
3. **Callable** ‚Äî task can return value & throw exceptions, must be submitted to ExecutorService for async
4. **ExecutorService** ‚Äî modern best practice, manages thread pool, reuses threads, handles lifecycle and exceptions


### üîπ Extra tips for interviews:
1. When asked _‚ÄúWays to create a thread‚Äù_:
    - Mention **Thread**, **Runnable**, **Callable**, **ExecutorService** (maybe also **CompletableFuture** as modern shortcut).
2. When asked _‚ÄúWhich one is preferred?‚Äù_
    - Say: **ExecutorService / Thread pools** ‚Äî decouples tasks, manages resources, scalable.
3. Key points to highlight:
    - **Runnable**: task doesn‚Äôt return value
    - **Callable**: task returns value + throws exceptions
    - **ExecutorService**: handles threading, pooling, lifecycle

## **1Ô∏è‚É£ Extend the `Thread` class
- Create a class that **extends Thread
- Override `run()` with the code to execute
- Call **`start()`** to run the thread

```
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running");
    }
}

new MyThread().start();

```
**Pros:** Simple to use  
**Cons:** Cannot extend another class; task + thread are combined

## **2Ô∏è‚É£ Implement `Runnable` interface
- Implement `Runnable` (single `run()` method)
- Pass it to a `Thread` object
- Call **`start()`**

Options 1: Classic Way
```
class MyTask implements Runnable {
    public void run() {
        System.out.println("Task running");
    }
}

new Thread(new MyTask()).start();
```
**Pros:** Task separated from thread; can extend another class  
**Cons:** Still manually manage thread lifecycle
‚úÖ Works fine, but **boilerplate** ‚Äî especially for small tasks.

Option 2: Anonymous Inner Class
```
new Thread(new Runnable() {
    public void run() {
        System.out.println("Task running");
    }
}).start();

```
- No need for a separate class file
- Useful for small one-off tasks

Option 3: Lambda
Since `Runnable` is a **functional interface** (single abstract method), you can use a **lambda**:
```
new Thread(() -> System.out.println("Task running")).start();

```
- Shortest and cleanest
    
- Most common in modern Java

## **3Ô∏è‚É£ Implement `Callable` interface** (Java 5+)
- `Callable<V>` allows **returning a result** and throwing exceptions
- Submit to an **ExecutorService**

Option 1: Run without executor
```
Callable<Integer> task = () -> {
    Thread.sleep(1000);
    return 42;
};

try {
    Integer result = task.call(); // runs in current thread
    System.out.println(result);   // 42
} catch (Exception e) {
    e.printStackTrace();
}

```

Option 2: With Executor
> ‚ÄúCallable is just a task that can return a value. You can call `call()` directly, but it will run in the current thread. To execute it asynchronously and retrieve a result, you should use an ExecutorService, which returns a Future.‚Äù

```
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(task);

System.out.println(future.get()); // blocks until done
executor.shutdown();

```
**Pros:** Returns value, supports exceptions, works well with thread pools  
**Cons:** Must use `Future` to get result

## **4Ô∏è‚É£ Use Executor / ExecutorService** (Preferred Modern Way)
- Decouples task submission from thread creation
- Handles **thread pooling**, reuse, lifecycle, and queueing

a) **Running a Runnable**
```
ExecutorService executor = Executors.newFixedThreadPool(2);

Runnable task = () -> System.out.println("Runnable running");
executor.submit(task); // returns Future<?> (can ignore)
executor.shutdown();
```
- The `Future<?>` returned **does not have a result
- Useful for tasks that **don‚Äôt return anything**

b) **Running a Callable**
```
Callable<Integer> task = () -> {
    Thread.sleep(1000);
    return 42;
};

ExecutorService executor = Executors.newFixedThreadPool(2);
Future<Integer> future = executor.submit(task);

System.out.println(future.get()); // blocks until result ready
executor.shutdown();

```
- Callable **returns a value** via `Future`
- Can throw checked exceptions

| Aspect                   | Manual Threads (`Thread`)        | ExecutorService / Thread Pool             |
| ------------------------ | -------------------------------- | ----------------------------------------- |
| **Creation**             | `new Thread(task).start()`       | `executor.submit(task)`                   |
| **Reuse**                | ‚ùå No ‚Äî thread dies after `run()` | ‚úÖ Yes ‚Äî threads reused in pool            |
| **Memory Usage**         | High if many threads             | Optimized ‚Äî fixed pool size               |
| **Lifecycle Management** | Manual (`start()`, `join()`)     | Automatic management by executor          |
| **Error Handling**       | Manual inside `run()`            | Can handle via Future, exception handlers |
| **Scalability**          | ‚ùå Poor for many tasks            | ‚úÖ High ‚Äî manages many tasks efficiently   |
| **Control**              | Each thread individual           | Pool controls concurrency and scheduling  |
| **Preferred Use**        | Small, one-off tasks             | Large, repeated, or parallel tasks        |
| **Code Complexity**      | High with many threads           | Lower, cleaner, less boilerplate          |
