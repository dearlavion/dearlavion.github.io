## What
ExecutorService decouples task definition from execution, reuses threads efficiently, and manages lifecycle automatically, unlike manually created threads.

## Why Executors Exist
**Problem with manual threads:**
- Creating threads manually is **resource-heavy**    
- Threads **die after run()**, no reuse
- Hard to manage lifecycle and errors
- Too many threads ‚Üí memory issues

**Solution: ExecutorService**
- **Separates tasks from thread management
- Uses **thread pools** to **reuse threads
- Manages **task queueing, scheduling, and shutdown
- Provides **better performance and scalability**


## Benefits of Using Executors

| Benefit                  | Why it matters                                                                  |
| ------------------------ | ------------------------------------------------------------------------------- |
| **Thread pooling**       | Reuses threads, avoids memory overhead of creating many threads                 |
| **Task queueing**        | Submits tasks faster than threads can execute; manages scheduling automatically |
| **Lifecycle management** | Executor handles start, completion, shutdown; no manual join() needed           |
| **Better performance**   | Reduces thread creation cost; optimizes CPU usage                               |

## Common Executors
### üîë Interview Talking Points
1. **Single thread** ‚Üí sequential, predictable
2. **Fixed pool** ‚Üí limited concurrency, tasks queue if no thread available
3. **Cached pool** ‚Üí dynamic threads, good for bursty tasks
4. **Scheduled pool** ‚Üí supports delayed and periodic execution

| Executor                    | Use Case                                                                    |
| --------------------------- | --------------------------------------------------------------------------- |
| `newSingleThreadExecutor()` | Runs tasks sequentially; one thread at a time                               |
| `newFixedThreadPool(n)`     | Limited parallelism; good for predictable workloads                         |
| `newCachedThreadPool()`     | Creates threads as needed; reuses idle threads; ideal for short-lived tasks |
| `ScheduledExecutorService`  | Run tasks after delay or periodically (like cron jobs)                      |

### 1Ô∏è‚É£ `newSingleThreadExecutor()` ‚Äî Sequential tasks
```
ExecutorService executor = Executors.newSingleThreadExecutor();

executor.submit(() -> System.out.println("Task 1"));
executor.submit(() -> System.out.println("Task 2"));
executor.submit(() -> System.out.println("Task 3"));

executor.shutdown();

```
Output:
```
Task 1
Task 2
Task 3
```
‚úÖ **Observation:** Tasks always run **in order**, one thread only.

### 2Ô∏è‚É£ `newFixedThreadPool(3)` ‚Äî Limited parallelism
```
ExecutorService executor = Executors.newFixedThreadPool(3);

for (int i = 1; i <= 6; i++) {
    final int taskId = i;
    executor.submit(() -> {
        System.out.println("Running Task " + taskId + " by " + Thread.currentThread().getName());
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
    });
}

executor.shutdown();

```
Output:
```
Running Task 1 by pool-1-thread-1
Running Task 2 by pool-1-thread-2
Running Task 3 by pool-1-thread-3
Running Task 4 by pool-1-thread-1
Running Task 5 by pool-1-thread-2
Running Task 6 by pool-1-thread-3
```
‚úÖ **Observation:** Only 3 tasks run concurrently; the rest wait in the queue.

### 3Ô∏è‚É£ `newCachedThreadPool()` ‚Äî Creates threads as needed
```
ExecutorService executor = Executors.newCachedThreadPool();

for (int i = 1; i <= 6; i++) {
    final int taskId = i;
    executor.submit(() -> {
        System.out.println("Running Task " + taskId + " by " + Thread.currentThread().getName());
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
    });
}

executor.shutdown();

```

Output:
```
Running Task 1 by pool-1-thread-1
Running Task 2 by pool-1-thread-2
Running Task 3 by pool-1-thread-3
Running Task 4 by pool-1-thread-4
Running Task 5 by pool-1-thread-5
Running Task 6 by pool-1-thread-6

```
‚úÖ **Observation:** New threads created as needed, **tasks run almost immediately**. Idle threads are reused if available.

### 4Ô∏è‚É£ `ScheduledExecutorService` ‚Äî Delayed / periodic tasks
```
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

scheduler.schedule(() -> System.out.println("Delayed task"), 2, TimeUnit.SECONDS);
scheduler.scheduleAtFixedRate(() -> System.out.println("Periodic task"), 0, 3, TimeUnit.SECONDS);

scheduler.schedule(() -> scheduler.shutdown(), 10, TimeUnit.SECONDS);

```

Output:
```
Periodic task
Delayed task
Periodic task
Periodic task
Periodic task

```
‚úÖ **Observation:**
- `Delayed task` runs **after 2 seconds**
- `Periodic task` runs **every 3 seconds** starting immediately